package main

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"
	"strings"

	"github.com/golang/glog"
	"github.com/golang/protobuf/proto"
	desc "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/descriptor"
	gen "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/generator"
	"github.com/valyala/fasttemplate"
	"reflect"
	"strconv"
)

var (
	templateEnum = fasttemplate.New("export const {enumType}_{enumName} = {enumValue};\n", "{", "}")
)

type generator struct {
	reg *descriptor.Registry
}

// New returns a new generator which generates grpc gateway files.
func NewGenerator(reg *descriptor.Registry) gen.Generator {
	return &generator{reg: reg}
}

func (g *generator) getFileName(file *descriptor.File) string {
	n := file.GetName()
	return n
}

func (g *generator) importName(file *descriptor.File) string {
	fname := g.getFileName(file)
	fbase := file.GetPackage() + "_" + strings.TrimSuffix(fname, filepath.Ext(fname))
	fbase = strings.Replace(fbase, "/", "_", -1)
	fbase = strings.Replace(fbase, ".", "_", -1)
	fbase = strings.Replace(fbase, "-", "_", -1)
	return fbase
}

func (g *generator) getRawTypeName(file *descriptor.File, a string) string {
	m, err := g.reg.LookupMsg(file.GetPackage(), a)
	isMessage := false
	isEnum := false
	prefix := ""
	if err == nil {
		isMessage = true
	}
	e, err := g.reg.LookupEnum(file.GetPackage(), a)
	if err == nil {
		isEnum = true
	}
	ss := strings.Split(a, ".")
	if isMessage {
		if len(m.Outers) > 0 {
			prefix = strings.Join(m.Outers, "")
		}
	} else if isEnum {
		if len(e.Outers) > 0 {
			prefix = strings.Join(e.Outers, "")
		}
	} else {
		panic(fmt.Errorf("%s is not message or enum", a))
		return ""
	}
	return prefix + ss[len(ss) - 1]
}

func (g *generator) getTypeName(t desc.FieldDescriptorProto_Type, field *desc.FieldDescriptorProto, file *descriptor.File) string {
	switch t {
	case desc.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case desc.FieldDescriptorProto_TYPE_FIXED32, desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "number"
	case desc.FieldDescriptorProto_TYPE_FLOAT, desc.FieldDescriptorProto_TYPE_INT32, desc.FieldDescriptorProto_TYPE_UINT32:
		return "number"
	case desc.FieldDescriptorProto_TYPE_INT64, desc.FieldDescriptorProto_TYPE_FIXED64, desc.FieldDescriptorProto_TYPE_UINT64:
		return "string|number"
	case desc.FieldDescriptorProto_TYPE_BYTES:
		return "string"
	case desc.FieldDescriptorProto_TYPE_ENUM:
		return "number"
	//		return g.getRawTypeName(file, field.GetTypeName())
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		return g.getRawTypeName(file, field.GetTypeName())
	default:
		return "any"
	}
}

func (g *generator) isMap(field *desc.FieldDescriptorProto, file *descriptor.File) bool {
	m, err := g.reg.LookupMsg(file.GetPackage(), field.GetTypeName())
	if err != nil {
		return false
	}
	return m.GetOptions().GetMapEntry()
}

func (g *generator) printMessageField(w io.Writer, field *desc.FieldDescriptorProto, file *descriptor.File) {
	if g.isMap(field, file) {
		fmt.Fprintf(w, "  %s: Object;\n", field.GetJsonName())
	} else if field.GetLabel() == desc.FieldDescriptorProto_LABEL_REPEATED {
		tn := g.getTypeName(field.GetType(), field, file)
		if strings.Index(tn, "|") > -1 {
			tn = strings.Replace(tn, "|", "[]|", 1)
		}
		fmt.Fprintf(w, "  %s: %s[];\n", field.GetJsonName(), tn)
	} else {
		fmt.Fprintf(w, "  %s: %s;\n", field.GetJsonName(), g.getTypeName(field.GetType(), field, file))
	}
}

func ToJsonName(pre string) string {
	if len(pre) == 0 {
		return ""
	}
	word := pre[:1]
	ss := make([]string, 0)
	for i := 1; i < len(pre); i++ {
		letter := pre[i : i + 1]
		if word != "" && strings.ToUpper(letter) == letter {
			ss = append(ss, word)
			if letter != "_" && letter != "-" {
				word = letter
			} else {
				word = ""
			}
		} else {
			word += letter
		}
	}
	ss = append(ss, word)
	for i, v := range ss {
		if i != 0 {
			ss[i] = strings.Title(v)
		} else {
			ss[0] = strings.ToLower(ss[0])
		}
	}
	return strings.Join(ss, "")
}

func ToParamName(pre string) string {
	ss := strings.Split(pre, ".")
	return ToJsonName(ss[len(ss) - 1])
}
func printComment(b io.Writer, comment string) {
	if len(comment) > 0 {
		fmt.Fprintf(b, "/**\n%s\n*/\n", comment)
	}
}
func (g *generator) generate(file *descriptor.File, index io.Writer) (string, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, `// Code generated by protoc-gen-react-typings.
// DO NOT EDIT!
'use strict';
`)

	for _, m := range file.Messages {
		if m.GetOptions().GetMapEntry() {
			continue
		}
		prefix := ""
		if len(m.Outers) > 0 {
			prefix = strings.Join(m.Outers, "")
		}
		fmt.Fprintf(index, "export interface %s {\n", prefix + m.GetName())
		for _, f := range m.GetField() {
			g.printMessageField(index, f, file)
		}
		fmt.Fprintln(index, "}\n")
		newTemp := `
/**
 *
 * @returns { {{returnType}} }
 */
export function new{{returnType}}(){
	return {};
}
`
		fasttemplate.Execute(newTemp, "{{", "}}", &buf, map[string]interface{}{
			"returnType": m.GetName(),
		})
	}

	//methProtoPath := protoPathIndex(reflect.TypeOf((*desc.ServiceDescriptorProto)(nil)), "Method")

	for svcIdx, s := range file.Services {
		tmpHeader := `
import { NativeModules } from 'react-native';
/**
 *
 * @returns { {{serviceName}} }
 */
function __{{serviceName}}() {
    return NativeModules.{{serviceName}};
}

export const {{serviceName}} = __{{serviceName}}();
`
		fasttemplate.Execute(tmpHeader, "{{", "}}", &buf, map[string]interface{}{
			"serviceName": s.GetName(),
		})

		printComment(index, protoComments(g.reg, s.File, nil, "Service", int32(svcIdx)))

		fasttemplate.Execute(`
interface {{serviceName}} {
	NAME: string;
`, "{{", "}}", index, map[string]interface{}{
			"serviceName": s.GetName(),
		})
		methProtoPath := protoPathIndex(reflect.TypeOf((*desc.ServiceDescriptorProto)(nil)), "Method")
		for methIdx, m := range s.Methods {
			printComment(index, protoComments(g.reg, s.File, nil, "Service", int32(svcIdx), methProtoPath, int32(methIdx)))
			server := m.GetServerStreaming()
			client := m.GetClientStreaming()
			if !server && !client {
				fasttemplate.Execute(`    {{methodName}}(req: {{requestType}}): Promise<{{responseType}}>;
`, "{{", "}}", index, map[string]interface{}{
					"methodName":   ToJsonName(m.GetName()),
					"requestType":  m.RequestType.GetName(),
					"responseType": m.ResponseType.GetName(),
				})
			} else if server && client {
				fasttemplate.Execute(`    start{{bigMethodName}}(cb: (resp: {{responseType}}, done: boolean, err: string) => void): Promise<string>;
	{{methodName}}(id: string, action: string, event: {{requestType}});
`, "{{", "}}", index, map[string]interface{}{
					"methodName":    ToJsonName(m.GetName()),
					"bigMethodName": strings.Title(ToJsonName(m.GetName())),
					"requestType":   m.RequestType.GetName(),
					"responseType":  m.ResponseType.GetName(),
				})
			} else if server && !client {
				fasttemplate.Execute(`    {{methodName}}(req: {{requestType}}, cb: (resp: {{responseType}}, done: boolean, err: string) => void);
`, "{{", "}}", index, map[string]interface{}{
					"methodName":   ToJsonName(m.GetName()),
					"requestType":  m.RequestType.GetName(),
					"responseType": m.ResponseType.GetName(),
				})
			}
		}
		fmt.Fprint(index, `}
`)

	}
	valueProtoPath := protoPathIndex(reflect.TypeOf((*desc.EnumDescriptorProto)(nil)), "Value")
	for _, e := range file.Enums {
		printComment(&buf, protoComments(g.reg, e.File, e.Outers, "EnumType", int32(e.Index)))
		enumType := e.GetName()
		if len(e.Outers) > 0 {
			enumType = strings.Join(e.Outers, "") + enumType
		}
		for i, v := range e.GetValue() {
			printComment(&buf, protoComments(g.reg, e.File, e.Outers, "EnumType", int32(e.Index), valueProtoPath, int32(i)))
			templateEnum.Execute(&buf, map[string]interface{}{
				"enumType":  enumType,
				"enumName":  v.GetName(),
				"enumValue": strconv.Itoa(int(v.GetNumber())),
			})
		}
		fmt.Fprintln(&buf, "")
	}
	return buf.String(), nil
}

func (g *generator) Generate(targets []*descriptor.File) ([]*plugin.CodeGeneratorResponse_File, error) {
	var files []*plugin.CodeGeneratorResponse_File
	var index bytes.Buffer
	for _, file := range targets {
		str, err := g.generate(file, &index)
		if err != nil {
			return nil, err
		}
		name := file.GetName()
		ext := filepath.Ext(name)
		base := strings.TrimSuffix(name, ext)
		output := fmt.Sprintf("%s.js", base)
		files = append(files, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(output),
			Content: proto.String(str),
		})
		glog.V(1).Infof("Will emit %s", output)
	}
	files = append(files, &plugin.CodeGeneratorResponse_File{
		Name:    proto.String("index.d.ts"),
		Content: proto.String(index.String()),
	})
	return files, nil
}

func protoComments(reg *descriptor.Registry, file *descriptor.File, outers []string, typeName string, typeIndex int32, fieldPaths ...int32) string {
	if file.SourceCodeInfo == nil {
		// Curious! A file without any source code info.
		// This could be a test that's providing incomplete
		// descriptor.File information.
		//
		// We could simply return no comments, but panic
		// could make debugging easier.
		panic("descriptor.File should not contain nil SourceCodeInfo")
	}

	outerPaths := make([]int32, len(outers))
	for i := range outers {
		location := ""
		if file.Package != nil {
			location = file.GetPackage()
		}

		msg, err := reg.LookupMsg(location, strings.Join(outers[:i + 1], "."))
		if err != nil {
			panic(err)
		}
		outerPaths[i] = int32(msg.Index)
	}

	for _, loc := range file.SourceCodeInfo.Location {
		if !isProtoPathMatches(loc.Path, outerPaths, typeName, typeIndex, fieldPaths) {
			continue
		}
		comments := ""
		if loc.LeadingComments != nil {
			comments = strings.TrimRight(*loc.LeadingComments, "\n")
			comments = strings.TrimSpace(comments)
			// TODO(ivucica): this is a hack to fix "// " being interpreted as "//".
			// perhaps we should:
			// - split by \n
			// - determine if every (but first and last) line begins with " "
			// - trim every line only if that is the case
			// - join by \n
			comments = strings.Replace(comments, "\n ", "\n", -1)
		}
		return comments
	}
	return ""
}

var messageProtoPath = protoPathIndex(reflect.TypeOf((*desc.FileDescriptorProto)(nil)), "MessageType")
var nestedProtoPath = protoPathIndex(reflect.TypeOf((*desc.DescriptorProto)(nil)), "NestedType")
var packageProtoPath = protoPathIndex(reflect.TypeOf((*desc.FileDescriptorProto)(nil)), "Package")

func isProtoPathMatches(paths []int32, outerPaths []int32, typeName string, typeIndex int32, fieldPaths []int32) bool {
	if typeName == "Package" && typeIndex == packageProtoPath {
		// path for package comments is just [2], and all the other processing
		// is too complex for it.
		if len(paths) == 0 || typeIndex != paths[0] {
			return false
		}
		return true
	}

	if len(paths) != len(outerPaths) * 2 + 2 + len(fieldPaths) {
		return false
	}

	typeNameDescriptor := reflect.TypeOf((*desc.FileDescriptorProto)(nil))
	if len(outerPaths) > 0 {
		if paths[0] != messageProtoPath || paths[1] != outerPaths[0] {
			return false
		}
		paths = paths[2:]
		outerPaths = outerPaths[1:]

		for i, v := range outerPaths {
			if paths[i * 2] != nestedProtoPath || paths[i * 2 + 1] != v {
				return false
			}
		}
		paths = paths[len(outerPaths) * 2:]

		if typeName == "MessageType" {
			typeName = "NestedType"
		}
		typeNameDescriptor = reflect.TypeOf((*desc.DescriptorProto)(nil))
	}

	if paths[0] != protoPathIndex(typeNameDescriptor, typeName) || paths[1] != typeIndex {
		return false
	}
	paths = paths[2:]

	for i, v := range fieldPaths {
		if paths[i] != v {
			return false
		}
	}
	return true
}

// protoPathIndex returns a path component for google.protobuf.descriptor.SourceCode_Location.
//
// Specifically, it returns an id as generated from descriptor proto which
// can be used to determine what type the id following it in the path is.
// For example, if we are trying to locate comments related to a field named
// `Address` in a message named `Person`, the path will be:
//
//     [4, a, 2, b]
//
// While `a` gets determined by the order in which the messages appear in
// the proto file, and `b` is the field index specified in the proto
// file itself, the path actually needs to specify that `a` refers to a
// message and not, say, a service; and  that `b` refers to a field and not
// an option.
//
// protoPathIndex figures out the values 4 and 2 in the above example. Because
// messages are top level objects, the value of 4 comes from field id for
// `MessageType` inside `google.protobuf.descriptor.FileDescriptor` message.
// This field has a message type `google.protobuf.descriptor.DescriptorProto`.
// And inside message `DescriptorProto`, there is a field named `Field` with id
// 2.
//
// Some code generators seem to be hardcoding these values; this method instead
// interprets them from `descriptor.proto`-derived Go source as necessary.
func protoPathIndex(descriptorType reflect.Type, what string) int32 {
	field, ok := descriptorType.Elem().FieldByName(what)
	if !ok {
		panic(fmt.Errorf("Could not find protobuf descriptor type id for %s.", what))
	}
	pbtag := field.Tag.Get("protobuf")
	if pbtag == "" {
		panic(fmt.Errorf("No Go tag 'protobuf' on protobuf descriptor for %s.", what))
	}
	path, err := strconv.Atoi(strings.Split(pbtag, ",")[1])
	if err != nil {
		panic(fmt.Errorf("Protobuf descriptor id for %s cannot be converted to a number: %s", what, err.Error()))
	}

	return int32(path)
}
